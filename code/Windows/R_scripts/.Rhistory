#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#density plot of r2 of sim and real pop
plot(density(sample(res_rec[["all.LG"]][["r2"]], 100))
#density plot of r2 of sim and real pop
plot(density(sample(res_rec[["all.LG"]][["r2"]], 100)))
#density plot of r2 of sim and real pop
plot(density(sample(res_rec[["all.LG"]][["r2"]], 100)))
plot(density(sample(res_pop1[["all.LG"]][["r2"]]), 100))
plot(density(sample(res_pop1[["all.LG"]][["r2"]]), 100))
#density plot of r2 of sim and real pop
plot(density(sample(res_rec[["all.LG"]][["r2"]], 100)))
plot(density(sample(res_pop1[["all.LG"]][["r2"]]), 100))
#density plot of r2 of sim and real pop
plot(density(sample(res_rec[["all.LG"]][["r2"]], 100)))
plot(density(sample(res_pop1[["all.LG"]][["r2"]], 100)))
#density plot of r2 of sim and real pop
plot(density(res_rec[["all.LG"]][["r2"]]))
plot(density(res_pop1[["all.LG"]][["r2"]]))
#density of no rec and ks test between rec and no rec
plot(density(res_norec[["all.LG"]][["r2"]]))
ks.test(res_rec[["all.LG"]][["r2"]], res_norec[["all.LG"]][["r2"]])
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_norec[["all.LG"]][["r2"]]), 100)
library(adegenet)
data(microsatt)
x <- as.genpop(microsatt$tab)
View(x)
#allele counts
x@tab
library(stats)
dist(whole_add, method = "euclidean")
dist(whole_add, method = "euclidean") -> test
plot(density(test))
boxplot(test)
#distance measure (e.g. euclidian distance/rogers distance)
boxplot(dist(whole_add, method = "euclidean"))
boxplot(dist(add_1, method = "euclidean"))
duplicated(whole_add)
?plot
plot_LD_decay <- function(est, title){
with(est$all.LG, plot(r2~d,col=transp("cadetblue"),
xlim=c(0,55), ylim=c(0,1),
pch=20,cex=0.5,yaxt="n",
xaxt="n",ylab=expression(r^2),
xlab="Distance in cM",main=title)
)
}
plot_LD_decay(res_rec, "LD vs R2 in recombination simulation")
plot_LD_decay(res_rec, "R2~D in recombination simulation")
calculate_pairwise_differences <- function(sequences) {
num_sequences <- length(sequences)
pairwise_diff <- numeric(choose(num_sequences, 2))  # Initialize vector to store pairwise differences
# Iterate over all pairs of sequences
k <- 1
for (i in 1:(num_sequences - 1)) {
for (j in (i + 1):num_sequences) {
# Compare nucleotide positions and count differences
differences <- sum(sequences[[i]] != sequences[[j]])
pairwise_diff[k] <- differences
k <- k + 1
}
}
return(pairwise_diff)
}
# Example usage
# Replace the following list with your actual DNA sequences
dna_sequences <- list("ATCG", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(dna_sequences)
# Print the result
cat("Pairwise Differences:", pairwise_differences, "\n")
# Example usage
# Replace the following list with your actual DNA sequences
dna_sequences <- list("ATATAT", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(dna_sequences)
# Print the result
cat("Pairwise Differences:", pairwise_differences, "\n")
# Example usage
# Replace the following list with your actual DNA sequences
dna_sequences <- list("ATATATATAT", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(dna_sequences)
# Print the result
cat("Pairwise Differences:", pairwise_differences, "\n")
# Example usage
# Replace the following list with your actual DNA sequences
dna_sequences <- list("GGGG", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(dna_sequences)
# Print the result
cat("Pairwise Differences:", pairwise_differences, "\n")
seqs <- list("GGGG", "ATGG", "ATCC", "AACC")
sum(seqs[[1]] != seqs[[2]])
sum(seqs[[1]] != seqs[[3]])
seqs[[1]]
strsplit(seqs[[1]])
strsplit(seqs[[1]], split = "")
sum(strsplit(seqs[[1]], split = "") != strsplit(seqs[[2]], split = ""))
strsplit(seqs[[1]], split = "")
unlist(strsplit(seqs[[1]], split = ""))
sum(unlist(strsplit(seqs[[1]], split = "")) != unlist(strsplit(seqs[[2]], split = "")))
num_sequences <- length(sequences)
calculate_pairwise_differences <- function(sequences) {
num_sequences <- length(sequences)
pairwise_diff <- numeric(choose(num_sequences, 2))  # Initialize vector to store pairwise differences
# Iterate over all pairs of sequences
k <- 1
for (i in 1:(num_sequences - 1)) {
for (j in (i + 1):num_sequences) {
# Compare nucleotide positions and count differences
differences <- sum(unlist(strsplit(sequences[[i]], split = "")) != unlist(strsplit(sequences[[j]], split = "")))
pairwise_diff[k] <- differences
k <- k + 1
}
}
return(pairwise_diff)
}
# Example usage
# Replace the following list with your actual DNA sequences
dna_sequences <- list("GGGG", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(dna_sequences)
# Print the result
cat("Pairwise Differences:", pairwise_differences, "\n")
seqs[[1]]
length(seqs[[1]])
calculate_pairwise_differences <- function(sequences) {
num_sequences <- length(sequences)
pairwise_diff <- numeric(choose(num_sequences, 2))  # Initialize vector to store pairwise differences
# Iterate over all pairs of sequences
k <- 1
for (i in 1:(num_sequences - 1)) {
for (j in (i + 1):num_sequences) {
# Compare nucleotide positions and count differences
differences <- sum(unlist(strsplit(sequences[[i]], split = "")) != unlist(strsplit(sequences[[j]], split = "")))
pairwise_diff[k] <- differences
k <- k + 1
}
}
pairwise_diff <- pairwise_diff/length(unlist(strsplit(sequences[[1]], split = "")))
return(pairwise_diff)
}
sequences <- list("GGGG", "ATGG", "ATCC", "AACC")
# Calculate pairwise differences
pairwise_differences <- calculate_pairwise_differences(sequences)
pairwise_differences
rep(0.1,6)
# Function to calculate nucleotide diversity estimator
calculate_nucleotide_diversity <- function(frequencies, pairwise_differences, n) {
# Ensure lengths of input vectors match
if (length(frequencies) != n || length(pairwise_differences) != choose(n, 2)) {
stop("Input vector lengths do not match the specified number of sequences.")
}
# Calculate nucleotide diversity
pi_hat <- (n/(n-1)) * sum(outer(frequencies, frequencies, "*") * pairwise_differences)
return(pi_hat)
}
calculate_nucleotide_diversity(rep(0.1,6), pairwise_differences, 6)
calculate_nucleotide_diversity(rep(0.1,4), pairwise_differences, 4)
#distance measure (e.g. euclidian distance/rogers distance)
boxplot(dist(whole_add, method = "euclidean"), main = "test")
#distance measure (e.g. euclidian distance/rogers distance)
boxplot(dist(whole_add, method = "euclidean"), main = "Euclidean distance of additive encoding simulated")
#distance measure (e.g. euclidian distance/rogers distance)
boxplot(dist(whole_add, method = "euclidean"), main = "Euclidean distance of additive encoding simulated")
boxplot(dist(add_1, method = "euclidean"), main = "Euclidean distance of additive encoding real pop")
#nucleotide diversity (overall and across sites)
pop_1_geno <- read.csv("data/test_data/pop_1_genos.csv")
#nucleotide diversity (overall and across sites)
pop_1_geno <- read.csv("../data/test_data/pop_1_genos.csv")
pop_1_geno
View(pop_1_geno)
pop_1_geno <- pop_1_geno[-1]
list(pop_1_geno)
list(pop_1_geno)->test
View(test)
View(sequences)
split(pop_1_geno, seq(nrow(pop_1_geno)))
split(pop_1_geno, seq(nrow(pop_1_geno))) -> test
View(test)
apply(pop_1_geno, 1, function(row) as.list(row))
apply(pop_1_geno, 1, function(row) paste(row, collapse = ""))
apply(pop_1_geno, 1, function(row) paste(row, collapse = "")) -> test
as.list(test)
as.list(test) -> test
View(test)
#nucleotide diversity (overall and across sites)
pop_1_geno <- read.csv("../data/test_data/pop_1_genos.csv")
pop_1_geno <- pop_1_geno[-1]
pop_1_list <- apply(pop_1_geno, 1, function(row) paste(row, collapse = ""))
pop_1_list <- as.list(pop_1_list)
View(pop_1_list)
duplicated(pop_1_geno)
#sequence frequency?
duplicated(pop_1_geno)
#all dissimilar
seq_freq <- rep(1/194, 194)
pop_1_pd <- calculate_pairwise_differences(pop_1_list)
pop_1_pd
calculate_nucleotide_diversity(seq_freq, pop_1_pd, 194)
#nucleotide diversity (overall and across sites)
rec_geno <- read.csv("../data/sim_output/whole_sim.csv")
View(rec_geno)
#nucleotide diversity (overall and across sites)
rec_geno <- read.csv("../data/sim_output/whole_sim.csv", row.names = FALSE)
?read.csv
rec_geno <- rec_geno[-c(1,2)]
#sequence frequency?
duplicated(rec_geno)
rec_list <- apply(rec_geno, 1, function(row) paste(row, collapse = ""))
rec_list <- as.list(rec_list)
rec_pd <- calculate_pairwise_differences(rec_list)
calculate_nucleotide_diversity(seq_freq, rec_pd, 194)
# Function to calculate nucleotide diversity estimate across sites for every site
calculate_nucleotide_diversity_across_sites <- function(sequences) {
num_sequences <- length(sequences)
num_sites <- nchar(sequences[[1]])
pi_hat_across_sites <- numeric(num_sites)  # Initialize vector to store results for each site
# Iterate over all sites
for (site in 1:num_sites) {
# Extract nucleotides at the current site for all sequences
site_nucleotides <- sapply(sequences, function(seq) substr(seq, site, site))
# Calculate pairwise differences for the current site
pairwise_diff <- calculate_pairwise_differences(list(site_nucleotides))
# Calculate nucleotide diversity estimate for the current site
pi_hat_across_sites[site] <- calculate_nucleotide_diversity(rep(1, num_sequences), pairwise_diff, num_sequences)
}
return(pi_hat_across_sites)
}
dna_sequences <- list("ATCG", "ATGG", "ATCC", "AACC")
# Calculate nucleotide diversity estimate across sites
result_across_sites <- calculate_nucleotide_diversity_across_sites(dna_sequences)
map <- read.csv("../data/test_data/B73_genmap.csv")
#keep Locus/Marker, Position and LG/Chromosome
map <- map[,c("Marker", "Map.cM.", "Chromosome")]
colnames(map) <- c("Locus","Position","LG")
plot_LD_decay <- function(est, title){
with(est$all.LG, plot(r2~d,col=transp("cadetblue"),
xlim=c(0,55), ylim=c(0,1),
pch=20,cex=0.5,yaxt="n",
xaxt="n",ylab=expression(r^2),
xlab="Distance in cM",main=title)
)
}
#LD decay with recombination
whole_add <- read.csv("../data/sim_output/whole_add.csv")
whole_add <- whole_add[-1]
res_rec <- LD.decay(whole_add, map)
res_rec$all.LG <- res_rec$all.LG[(res_rec$all.LG$p < .001),]
library(sommer)
library(stats)
source("nuc_diversity.R")
map <- read.csv("../data/test_data/B73_genmap.csv")
#keep Locus/Marker, Position and LG/Chromosome
map <- map[,c("Marker", "Map.cM.", "Chromosome")]
colnames(map) <- c("Locus","Position","LG")
plot_LD_decay <- function(est, title){
with(est$all.LG, plot(r2~d,col=transp("cadetblue"),
xlim=c(0,55), ylim=c(0,1),
pch=20,cex=0.5,yaxt="n",
xaxt="n",ylab=expression(r^2),
xlab="Distance in cM",main=title)
)
}
#LD decay with recombination
whole_add <- read.csv("../data/sim_output/whole_add.csv")
whole_add <- whole_add[-1]
res_rec <- LD.decay(whole_add, map)
res_rec$all.LG <- res_rec$all.LG[(res_rec$all.LG$p < .001),]
plot_LD_decay(res_rec, "R2~D in recombination simulation")
#LD decay in real population
add_1 <- read.csv("../data/sim_output/add_1.csv")
add_1 <- add_1[-1]
res_pop1 <- LD.decay(add_1, map)
res_pop1$all.LG <- res_pop1$all.LG[(res_pop1$all.LG$p < .001),]
plot_LD_decay(res_pop1, "R2~D in real population")
plot_LD_decay <- function(est, title){
with(est$all.LG, plot(r2~d,col=transp("cadetblue"),
xlim=c(0,55), ylim=c(0,1),
pch=20,cex=0.5,ylab=expression(r^2),
xlab="Distance in cM",main=title)
)
}
plot_LD_decay(res_rec, "R2~D in recombination simulation")
#LD decay in real population
add_1 <- read.csv("../data/sim_output/add_1.csv")
add_1 <- add_1[-1]
res_pop1 <- LD.decay(add_1, map)
res_pop1$all.LG <- res_pop1$all.LG[(res_pop1$all.LG$p < .001),]
plot_LD_decay(res_pop1, "R2~D in real population")
#density plot of r2 of sim and real pop
plot(density(res_rec[["all.LG"]][["r2"]]))
plot(density(res_pop1[["all.LG"]][["r2"]]))
#ks test on simulated and real pop
ks.test(res_rec[["all.LG"]][["r2"]], res_pop1[["all.LG"]][["r2"]])
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
View(res_norec)
plot_LD_decay(res_rec, "R2~D in recombination simulation")
whole_add
plot_LD_decay(res_pop1, "R2~D in real population")
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 100), sample(res_pop1[["all.LG"]][["r2"]]), 100)
#ks test on simulated and real pop
ks.test(res_rec[["all.LG"]][["r2"]], res_pop1[["all.LG"]][["r2"]])
View(res_rec)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#density plot of r2 of sim and real pop
plot(density(res_rec[["all.LG"]][["r2"]]))
plot(density(res_pop1[["all.LG"]][["r2"]]))
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#distance measure (e.g. euclidian distance/rogers distance)
boxplot(dist(whole_add, method = "euclidean"), main = "Euclidean distance of additive encoding simulated population")
boxplot(dist(add_1, method = "euclidean"), main = "Euclidean distance of additive encoding real population")
#distance measure (e.g. euclidian distance/rogers distance)
par(mfrow=c(1,2))
boxplot(dist(whole_add, method = "euclidean"), main = "Euclidean distance of additive encoding simulated population")
boxplot(dist(add_1, method = "euclidean"), main = "Euclidean distance of additive encoding real population")
#distance measure (e.g. euclidian distance/rogers distance)
par(mfrow=c(1,2))
boxplot(dist(whole_add, method = "euclidean"), main = "Euclidean distance of additive encoding simulated population", ylim = c(15,50))
boxplot(dist(add_1, method = "euclidean"), main = "Euclidean distance of additive encoding real population", ylim = c(15,50))
boxplot(dist(whole_add, method = "manhattan"), main = "Euclidean distance of additive encoding simulated population", ylim = c(15,50))
?dist
boxplot(dist(whole_add, method = "manhattan"), main = "Euclidean distance of additive encoding simulated population", ylim = c(15,50))
boxplot(dist(add_1, method = "manhattan"), main = "Euclidean distance of additive encoding real population", ylim = c(15,50))
boxplot(dist(whole_add, method = "manhattan"), main = "Euclidean distance of additive encoding simulated population")
boxplot(dist(add_1, method = "manhattan"), main = "Euclidean distance of additive encoding real population")
#distance measure (e.g. euclidian distance/rogers distance)
par(mfrow=c(1,2))
boxplot(dist(whole_add, method = "manhattan"), main = "Euclidean distance of additive encoding simulated population")
boxplot(dist(add_1, method = "manhattan"), main = "Euclidean distance of additive encoding real population")
#distance measure (e.g. euclidian distance/rogers distance)
par(mfrow=c(1,2))
boxplot(dist(whole_add, method = "manhattan"), main = "Euclidean distance of additive encoding simulated population", ylim=c(200,1200))
boxplot(dist(add_1, method = "manhattan"), main = "Euclidean distance of additive encoding real population", ylim=c(200,1200))
calculate_nucleotide_diversity(seq_freq, rec_pd, 194)
calculate_nucleotide_diversity(seq_freq, pop_1_pd, 194)
library(Matrix)
library(MASS)
library(crayon)
library(sommer)
#load data (pre-saved in the sommer package)
data(DT_wheat)
#prepare phenotypic data
colnames(DT_wheat) <- paste0("trait_",1:ncol(DT_wheat))
View(DT_wheat)
#load data (pre-saved in the sommer package)
data(DT_wheat)
View(GT_wheat)
#prepare phenotypic data
colnames(DT_wheat) <- paste0("trait_",1:ncol(DT_wheat))
DT_wheat <- as.data.frame(DT_wheat)
DT_wheat$sample_id <- as.factor(rownames(DT_wheat))
#add sample ids to genotypic data
rownames(GT_wheat) <- rownames(DT_wheat)
#generate additive relationship matrix (also called K.matrix)
K.matrix <- A.mat(GT_wheat)
View(K.matrix)
?A.mat
?mmer
library(Matrix)
library(MASS)
library(crayon)
library(sommer)
#load data (pre-saved in the sommer package)
data(DT_wheat)
#prepare phenotypic data
colnames(DT_wheat) <- paste0("trait_",1:ncol(DT_wheat))
DT_wheat <- as.data.frame(DT_wheat)
DT_wheat$sample_id <- as.factor(rownames(DT_wheat))
#add sample ids to genotypic data
rownames(GT_wheat) <- rownames(DT_wheat)
#Please, take a look into genotypic data, here a bi-allelic SNP call is equal to:
# -1 if homozygous for one allele (e.g. AA),  1 if homozygous for the other allele (e.g. TT), and  0 if heterozygous for one allele (e.g. AT).
#generate additive relationship matrix (also called K.matrix)
K.matrix <- A.mat(GT_wheat)
#Here, I separate a group of the genotypes to predict their phenotype
genotypes_to_predict<-sample(rownames(DT_wheat), 60, replace = FALSE)
validation_set<-DT_wheat[genotypes_to_predict,]
#take out such phenotypes from the training set
DT_wheat[genotypes_to_predict,1:4]<-NA
#run GBLUP
model <- mmer(trait_1 ~ 1, random = ~vsr(sample_id,Gu=K.matrix), rcov=~units, data = DT_wheat, verbose = FALSE)
#get overall mean
u <- model$Beta$Estimate
#get genotypic effects for each individual (breeding values)
geno_effects <- model$U$`u:sample_id`$trait_1
#get genotypic values (phenotypic estimated values)
estimated_phenotypes <- u + geno_effects
#check predictive accuracy
y <- estimated_phenotypes[genotypes_to_predict]
x <- validation_set[genotypes_to_predict,"trait_1"]
cor.test(y, x, method = "pearson")
plot(y ~ x, xlab="Observed values", ylab="Predicted values")
abline(lm(y ~ x), col = "blue")
model
View(model)
?hist
View(model)
model[["Beta"]][["Effect"]]
model[["Beta"]][["Trait"]]
map <- read.csv("../data/test_data/B73_genmap.csv")
map <- read.csv("../data/sim_data/B73_genmap.csv")
map <- read.csv("../data/sim_data/B73_genmap.csv")
#keep Locus/Marker, Position and LG/Chromosome
map <- map[,c("Marker", "Map.cM.", "Chromosome")]
colnames(map) <- c("Locus","Position","LG")
#data(DT_cpdata)
#CPgeno <- GT_cpdata
#CPgeno[1:5,1:5]
#
#mapCP <- MP_cpdata; head(mapCP)
#names(mapCP) <- c("Locus","Position","LG")
#
#mapCP <- mapCP[which(mapCP$LG <= 3),]
#
#res <- LD.decay(CPgeno, mapCP)
#names(res)
#
##constrain to significant LG with p < 0.001
#res$all.LG <- res$all.LG[which(res$all.LG$p < .001),]
plot_LD_decay <- function(est, title){
with(est$all.LG, plot(r2~d,col=transp("cadetblue"),
xlim=c(0,55), ylim=c(0,1),
pch=20,cex=0.5,ylab=expression(r^2),
xlab="Distance in cM",main=title)
)
}
#LD decay with recombination
whole_add <- read.csv("../sim_output/whole_add.csv")
whole_add <- whole_add[-1]
res_rec <- LD.decay(whole_add, map)
res_rec$all.LG <- res_rec$all.LG[(res_rec$all.LG$p < .001),]
plot_LD_decay(res_rec, "R2~D in recombination simulation")
#LD decay without recombination
#LD decay with recombination
whole_add <- read.csv("../sim_output/additive_encoding/geno_B73_B97.csv")
whole_add <- whole_add[-1]
res_rec <- LD.decay(whole_add, map)
res_rec$all.LG <- res_rec$all.LG[(res_rec$all.LG$p < .001),]
plot_LD_decay(res_rec, "R2~D in recombination simulation")
#LD decay in real population
add_1 <- read.csv("../data/NAM_genotype_data/pop_01_genos.csv")
add_1 <- add_1[-1]
res_pop1 <- LD.decay(add_1, map)
res_pop1$all.LG <- res_pop1$all.LG[(res_pop1$all.LG$p < .001),]
plot_LD_decay(res_pop1, "R2~D in real population")
res_pop1 <- LD.decay(add_1, map)
res_pop1$all.LG <- res_pop1$all.LG[(res_pop1$all.LG$p < .001),]
plot_LD_decay(res_pop1, "R2~D in real population")
warnings()
#LD decay in real population
add_1 <- read.csv("../data/NAM_genotype_data/pop_01_genos.csv")
View(add_1)
add_1 <- add_1[-1]
#LD decay in real population
add_1 <- read.csv("../data/test_data/pop_01_genos.csv")
add_1 <- add_1[-1]
#LD decay in real population
add_1 <- read.csv("../data/test_data/additive_1.csv")
add_1 <- add_1[-1]
res_pop1 <- LD.decay(add_1, map)
res_pop1$all.LG <- res_pop1$all.LG[(res_pop1$all.LG$p < .001),]
plot_LD_decay(res_pop1, "R2~D in real population")
par(mfrow=c(1,2))
plot_LD_decay(res_rec, "R2~D in recombination simulation")
plot_LD_decay(res_pop1, "R2~D in real population")
#ks test on simulated and real pop
ks.test(res_rec[["all.LG"]][["r2"]], res_pop1[["all.LG"]][["r2"]])
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#ks test on simulated and real pop
ks.test(sample(res_rec[["all.LG"]][["r2"]], 1000), sample(res_pop1[["all.LG"]][["r2"]]), 1000)
#smaller sample non-significant for alpha = 0.05
plot(density(sample(res_rec[["all.LG"]][["r2"]], 1000)))
plot(density(sample(res_pop1[["all.LG"]][["r2"]], 1000)))
