het_mat <- as.matrix(cbind(table(unlist(sim_add[sample,]) == 0), table(unlist(real_add[sample,]) == 0)))
#calc # of all genos
geno_names <- intersect(names(table(unlist(sim_geno[sample,]))), names(table(unlist(real_geno[sample,]))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno[sample,]))[geno_names],
table(unlist(real_geno[sample,]))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
#ks test
ks_p <- ks.test(rowSums(sim_add), rowSums(real_add))$p.value
#wasserstein dist
w1d <- wasserstein1d(rowSums(sim_add), rowSums(real_add))
##2. popgen stats
sim_ld <- LD.decay(sim_add, ld_map)
sim_ld$all.LG <- sim_ld$all.LG[(sim_ld$all.LG$p < .001),]
sim_r2_D <- sim_ld$all.LG[c("r2", "d")]
real_ld <- LD.decay(real_add, ld_map)
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$p < .001),]
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$r2 < .99),]
real_r2_D <- real_ld$all.LG[c("r2", "d")]
#ks test + w1d on r2 measure
ld_ks_p <- ks.test(sim_r2_D$r2, real_r2_D$r2)$p.value
ld_w1d <- wasserstein1d(sim_r2_D$r2, real_r2_D$r2)
#plot_ld_decay(real_r2_D, sim_r2_D, ld_ks_p, ld_w1d,
#              out_path = paste("../plots/popgen_plots/LD_decay/",i,"/ld_decay_",j,".png", sep = ""))
#format sumstats
p_vals <- c(het_p, geno_p, ks_p, ld_ks_p)
p_vals <- ifelse(p_vals < 0.001, "<0.001", round(p_vals,3))
effects <- round(c(het_phi, geno_cramersv, w1d, ld_w1d),2)
stats <- c(p_vals[1], effects[1], p_vals[2], effects[2], p_vals[3], effects[3], p_vals[4], effects[4])
sum_stats[sum_stats$population == j, c("het_p", "het_phi", "geno_p", "geno_cramersV", "ks_p", "w1d",
"ld_ks_p", "ld_w1d")] <- stats
}
print("finished")
write.csv(sum_stats, paste("../stats/sum_stats_",i,".csv", sep = ""), row.names = FALSE)
}
#read in sum stats to compare rec scenarios
sum_results <- data.frame("rec_param" = c("normal_rec", "high_rec", "zero_rec", "mean_rec"),
"het_sig" = NA, "mean_sd_phi" = NA, "geno_sig" = NA, "mean_sd_cramersV" = NA,
"ks_sig" = NA, "mean_sd_w1d" = NA, "ld_ks_sig", "mean_sd_ld_w1d")
for(i in rec_param){
sum_stats <- read.csv(paste("../stats/sum_stats_",i,".csv", sep = ""))
het_sig <- paste(table(sum_stats$het_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$het_p)), sep = "")
het_phi <- paste("median: ", median(sum_stats$het_phi), ", IQR: ", IQR(sum_stats$het_phi),
", mean: ", signif(mean(sum_stats$het_phi),3),
" ± ", signif(sd(sum_stats$het_phi),3), sep = "")
geno_sig <- paste(table(sum_stats$geno_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$geno_p)), sep = "")
geno_cramersV <- paste("median: ", median(sum_stats$geno_cramersV), ", IQR: ", IQR(sum_stats$geno_cramersV),
", mean: ", signif(mean(sum_stats$geno_cramersV),3),
" ± ", signif(sd(sum_stats$geno_cramersV),3), sep = "")
ks_sig <- paste(table(sum_stats$ks_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$ks_p)), sep = "")
w1d <- paste("median: ", median(sum_stats$w1d), ", IQR: ", IQR(sum_stats$w1d),
", mean: ", signif(mean(sum_stats$w1d),3),
" ± ", signif(sd(sum_stats$w1d),3), sep = "")
ld_ks_sig <- paste(table(sum_stats$ld_ks_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$ld_ks_p)), sep = "")
ld_w1d <- paste("median: ", median(sum_stats$ld_w1d), ", IQR: ", IQR(sum_stats$ld_w1d),
", mean: ", signif(mean(sum_stats$ld_w1d),3),
" ± ", signif(sd(sum_stats$ld_w1d),3), sep = "")
results <- c(het_sig, het_phi, geno_sig, geno_cramersV, ks_sig, w1d, ld_ks_sig, ld_w1d)
sum_results[sum_results$rec_param == i, c("het_sig", "mean_sd_phi", "geno_sig", "mean_sd_cramersV",
"ks_sig", "mean_sd_w1d", "ld_ks_sig", "mean_sd_ld_w1d")] <- results
}
View(sum_results)
#read in sum stats to compare rec scenarios
sum_results <- data.frame("rec_param" = c("normal_rec", "high_rec", "zero_rec", "mean_rec"),
"het_sig" = NA, "mean_sd_phi" = NA, "geno_sig" = NA, "mean_sd_cramersV" = NA,
"ks_sig" = NA, "mean_sd_w1d" = NA, "ld_ks_sig" = NA, "mean_sd_ld_w1d" = NA)
for(i in rec_param){
sum_stats <- read.csv(paste("../stats/sum_stats_",i,".csv", sep = ""))
het_sig <- paste(table(sum_stats$het_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$het_p)), sep = "")
het_phi <- paste("median: ", median(sum_stats$het_phi), ", IQR: ", IQR(sum_stats$het_phi),
", mean: ", signif(mean(sum_stats$het_phi),3),
" ± ", signif(sd(sum_stats$het_phi),3), sep = "")
geno_sig <- paste(table(sum_stats$geno_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$geno_p)), sep = "")
geno_cramersV <- paste("median: ", median(sum_stats$geno_cramersV), ", IQR: ", IQR(sum_stats$geno_cramersV),
", mean: ", signif(mean(sum_stats$geno_cramersV),3),
" ± ", signif(sd(sum_stats$geno_cramersV),3), sep = "")
ks_sig <- paste(table(sum_stats$ks_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$ks_p)), sep = "")
w1d <- paste("median: ", median(sum_stats$w1d), ", IQR: ", IQR(sum_stats$w1d),
", mean: ", signif(mean(sum_stats$w1d),3),
" ± ", signif(sd(sum_stats$w1d),3), sep = "")
ld_ks_sig <- paste(table(sum_stats$ld_ks_p == "<0.001")[["TRUE"]],"/",
sum(table(sum_stats$ld_ks_p)), sep = "")
ld_w1d <- paste("median: ", median(sum_stats$ld_w1d), ", IQR: ", IQR(sum_stats$ld_w1d),
", mean: ", signif(mean(sum_stats$ld_w1d),3),
" ± ", signif(sd(sum_stats$ld_w1d),3), sep = "")
results <- c(het_sig, het_phi, geno_sig, geno_cramersV, ks_sig, w1d, ld_ks_sig, ld_w1d)
sum_results[sum_results$rec_param == i, c("het_sig", "mean_sd_phi", "geno_sig", "mean_sd_cramersV",
"ks_sig", "mean_sd_w1d", "ld_ks_sig", "mean_sd_ld_w1d")] <- results
}
plot_ld_decay(real_r2_D, sim_r2_D, round(ld_ks_p,3), round(ld_w1d,2),
out_path = paste("../plots/popgen_plots/LD_decay/",i,"/ld_decay_",j,".png", sep = ""))
ld_ks_p <- ks.test(sim_r2_D$r2, real_r2_D$r2)$p.value
ld_w1d <- wasserstein1d(sim_r2_D$r2, real_r2_D$r2)
plot_ld_decay(real_r2_D, sim_r2_D, round(ld_ks_p,3), round(ld_w1d,2),
out_path = paste("../plots/popgen_plots/LD_decay/",i,"/ld_decay_",j,".png", sep = ""))
#format sumstats
dist_real
colnames(sim_add) <- c(1:974)
genind <- df2genind(sim_add, sep = "")
dist_sim <- dist.genpop(as.genpop(genind$tab), method = 4)
colnames(real_add) <- c(1:974)
genind <- df2genind(real_add, sep = "")
dist_real <- dist.genpop(as.genpop(genind$tab), method = 4)
library(sommer)
library(stats)
library(transport)
library(effectsize)
library(adegenet)
source("stat_functions.R")
colnames(sim_add) <- c(1:974)
genind <- df2genind(sim_add, sep = "")
dist_sim <- dist.genpop(as.genpop(genind$tab), method = 4)
colnames(real_add) <- c(1:974)
genind <- df2genind(real_add, sep = "")
dist_real <- dist.genpop(as.genpop(genind$tab), method = 4)
dist_real
as.numeric(dist_real)
library(ggpubr)
install.packages("purrr")
install.packages("purrr")
install.packages("purrr")
library(ggpubr)
install.packages("rlang")
install.packages("rlang")
library(ggpubr)
install.packages("ggpubr")
library(ggpubr)
library(ggpubr)
install.packages("rlang")
install.packages("rlang")
library(ggpubr)
set.seed(123)
data <- data.frame(
Group = rep(c("Group A", "Group B"), each = 50),
Value = c(rnorm(50, mean = 10, sd = 2), rnorm(50, mean = 12, sd = 2))
)
# Create a boxplot with ggplot2
p <- ggplot(data, aes(x = Group, y = Value, fill = Group)) +
geom_boxplot() +
theme_minimal()
# Add significance test p-value
p <- p + stat_compare_means(method = "t.test", label = "p.format",
aes(label = paste("p = ", signif(..p.format.., digits = 2))),
box.width = 0.4)
# Show the plot
print(p)
library(Matrix)
library(MASS)
library(crayon)
library(sommer)
##model comparison similar to john et al comparison of classical and ml methods 2022
##-> similar model ranking? + overall accuracy + feature usage for prediction as three outcomes
#load data (pre-saved in the sommer package)
data(DT_wheat)
#prepare phenotypic data
colnames(DT_wheat) <- paste0("trait_",1:ncol(DT_wheat))
DT_wheat <- as.data.frame(DT_wheat)
DT_wheat$sample_id <- as.factor(rownames(DT_wheat))
#add sample ids to genotypic data
rownames(GT_wheat) <- rownames(DT_wheat)
#Please, take a look into genotypic data, here a bi-allelic SNP call is equal to:
# -1 if homozygous for one allele (e.g. AA),  1 if homozygous for the other allele (e.g. TT), and  0 if heterozygous for one allele (e.g. AT).
#generate additive relationship matrix (also called K.matrix)
K.matrix <- A.mat(GT_wheat)
#Here, I separate a group of the genotypes to predict their phenotype
genotypes_to_predict<-sample(rownames(DT_wheat), 60, replace = FALSE)
validation_set<-DT_wheat[genotypes_to_predict,]
#take out such phenotypes from the training set
DT_wheat[genotypes_to_predict,1:4]<-NA
#run GBLUP
model <- mmer(trait_1 ~ 1, random = ~vsr(sample_id,Gu=K.matrix), rcov=~units, data = DT_wheat, verbose = FALSE)
#get overall mean
u <- model$Beta$Estimate
#get genotypic effects for each individual (breeding values)
geno_effects <- model$U$`u:sample_id`$trait_1
#get genotypic values (phenotypic estimated values)
estimated_phenotypes <- u + geno_effects
#check predictive accuracy
y <- estimated_phenotypes[genotypes_to_predict]
x <- validation_set[genotypes_to_predict,"trait_1"]
cor.test(y, x, method = "pearson")
plot(y ~ x, xlab="Observed values", ylab="Predicted values")
abline(lm(y ~ x), col = "blue")
?mse
??mse
y
x
sqrt((x-y)^2)/length(x)
sum(sqrt((x-y)^2))/length(x)
summary.lm(model)
?mmer
?A.mat
validation_set
A.mat
_sommer_amat
GT_wheat
View(GT_wheat)
small <- GT_wheat[1:10,1:10]
small
colMeans(small)
small - colMeans(small)
geno_names <- intersect(names(table(unlist(sim_geno[sample,]))), names(table(unlist(real_geno[sample,]))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno[sample,]))[geno_names],
table(unlist(real_geno[sample,]))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
library(sommer)
library(stats)
library(transport)
library(effectsize)
library(adegenet)
source("stat_functions.R")
geno_names <- intersect(names(table(unlist(sim_geno[sample,]))), names(table(unlist(real_geno[sample,]))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno[sample,]))[geno_names],
table(unlist(real_geno[sample,]))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
geno_p
geno_mat
het_p
het_mat
sample <- sample(c(1:populations[populations$pop == j, "size"]), 20)
het_mat <- as.matrix(cbind(table(unlist(sim_add[sample,]) == 0), table(unlist(real_add[sample,]) == 0)))
#calc # of all genos
geno_names <- intersect(names(table(unlist(sim_geno[sample,]))), names(table(unlist(real_geno[sample,]))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno[sample,]))[geno_names],
table(unlist(real_geno[sample,]))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
het_mat
het_p
het_phi
geno_p
geno_cramersv
het_mat <- as.matrix(cbind(table(unlist(sim_add) == 0), table(unlist(real_add) == 0)))
#calc # of all genos
geno_names <- intersect(names(table(unlist(sim_geno))), names(table(unlist(real_geno))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno))[geno_names],
table(unlist(real_geno))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
het_p
het_mat
het_phi
geno_p
geno_cramersv
library(sommer)
library(stats)
library(transport)
library(effectsize)
library(adegenet)
source("stat_functions.R")
##generate summary statistics for genotype simulation across all populations and recombination scenarios
#Stats implemented:
#1. distributional differences
#Table of simulated alleles in diploid gene sequence format
#Heterozygous/reference/derived alleles
#chisq test between tables (hetero+all)
#ks test + wasserstein distance for dist diff
#gc content distribution across all individuals+sites
#2. additional popgen stats
#linkage disequilibrium decay (r2~d)
#ks test/density of r2 between sim and real encoding
#distance measure (e.g. euclidean/rogers distance)
#read genmap to constrain markers/calc ld decay etc.
genmap <- read.csv("../data/sim_data/B73_genmap.csv")
#read populations
populations <- read.csv("../data/sim_data/populations.csv")
#LD decay
#keep Locus/Marker, Position and LG/Chromosome
ld_map <- genmap[,c("Marker", "Map.cM.", "Chromosome")]
colnames(ld_map) <- c("Locus","Position","LG")
#vary over all recombination parameters
rec_param <- c("normal_rec", "high_rec", "zero_rec", "mean_rec")
for(i in rec_param){
sum_stats <- data.frame("population" = populations$pop, "het_p" = NA, "het_phi" = NA, "geno_p" = NA,
"geno_cramersV" = NA, "ks_p" = NA, "w1d" = NA, "ld_ks_p" = NA, "ld_w1d" = NA,
"gc_p" = NA, "gc_cohens" = NA)
#vary over all simulated pops
for(j in populations$pop){
#read real and sim pop
sim_geno <- read.csv(paste("../sim_output/",i,"/geno_encoding/geno_",j,".csv", sep = ""))
real_geno <- read.csv(paste("../data/NAM_genotype_data/geno_encoding/pop_",j,"_genos.csv", sep = ""))
sim_add <- read.csv(paste("../sim_output/",i,"/additive_encoding/add_",j,".csv", sep = ""))
real_add <- read.csv(paste("../data/NAM_genotype_data/additive_encoding/pop_",j,"_add.csv", sep = ""))
#constrain to same markers
sim_geno <- sim_geno[,genmap$Marker]
real_geno <- real_geno[,genmap$Marker]
sim_add <- sim_add[,genmap$Marker]
real_add <- real_add[,genmap$Marker]
##1. dist stats
#calculate # of het
sample <- sample(c(1:populations[populations$pop == j, "size"]), 20)
het_mat <- as.matrix(cbind(table(unlist(sim_add) == 0), table(unlist(real_add) == 0)))
#calc # of all genos
geno_names <- intersect(names(table(unlist(sim_geno))), names(table(unlist(real_geno))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno))[geno_names],
table(unlist(real_geno))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
#ks test
ks_p <- ks.test(rowSums(sim_add), rowSums(real_add))$p.value
#wasserstein dist
w1d <- wasserstein1d(rowSums(sim_add), rowSums(real_add))
#gc content
haplo_mat_s <- cbind(apply(sim_geno,2,substr,1,1), apply(sim_geno,2,substr,2,2))
gc_vec_s <- apply(haplo_mat_s, 1, GC_cont)
haplo_mat_r <- cbind(apply(real_geno,2,substr,1,1), apply(real_geno,2,substr,2,2))
gc_vec_r <- apply(haplo_mat_r, 1, GC_cont)
gc_p <- t.test(gc_vec_s, gc_vec_r)$p.value
gc_cohens <- cohens_d(gc_vec_s, gc_vec_r)$Cohens_d
##2. popgen stats
sim_ld <- LD.decay(sim_add, ld_map)
sim_ld$all.LG <- sim_ld$all.LG[(sim_ld$all.LG$p < .001),]
sim_r2_D <- sim_ld$all.LG[c("r2", "d")]
real_ld <- LD.decay(real_add, ld_map)
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$p < .001),]
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$r2 < .99),]
real_r2_D <- real_ld$all.LG[c("r2", "d")]
#ks test + w1d on r2 measure
ld_ks_p <- ks.test(sim_r2_D$r2, real_r2_D$r2)$p.value
ld_w1d <- wasserstein1d(sim_r2_D$r2, real_r2_D$r2)
#adegenet does not like the original SNP names
colnames(sim_add) <- c(1:974)
genind <- df2genind(sim_add, sep = "")
dist_sim <- as.numeric(dist.genpop(as.genpop(genind$tab), method = 4))
colnames(real_add) <- c(1:974)
genind <- df2genind(real_add, sep = "")
dist_real <- as.numeric(dist.genpop(as.genpop(genind$tab), method = 4))
#rogers dist test
rogers_p <- t.test(dist_sim, dist_real)$p.value
rogers_cohen <- cohens_d(dist_sim, dist_real)$Cohens_d
#par(mfrow=c(1,2))
#boxplot(dist_sim, main = "Rogers distance of additive encoding simulated population", ylim=c(0.1,0.4))
#boxplot(dist_real, main = "Rogers distance of additive encoding real population", ylim=c(0.1,0.4))
#plot_ld_decay(real_r2_D, sim_r2_D, round(ld_ks_p,3), round(ld_w1d,2),
#              out_path = paste("../plots/popgen_plots/LD_decay/",i,"/ld_decay_",j,".png", sep = ""))
#format sumstats
p_vals <- c(het_p, geno_p, ks_p, ld_ks_p, gc_p)
p_vals <- ifelse(p_vals < 0.001, "<0.001", round(p_vals,3))
effects <- round(c(het_phi, geno_cramersv, w1d, ld_w1d, gc_cohens),2)
stats <- c(p_vals[1], effects[1], p_vals[2], effects[2], p_vals[3], effects[3], p_vals[4], effects[4],
p_vals[5], effects[5])
sum_stats[sum_stats$population == j, c("het_p", "het_phi", "geno_p", "geno_cramersV", "ks_p", "w1d",
"ld_ks_p", "ld_w1d", "gc_p", "gc_cohens")] <- stats
}
print("finished")
write.csv(sum_stats, paste("../stats/sum_stats_",i,".csv", sep = ""), row.names = FALSE)
}
sum_stats <- data.frame("population" = populations$pop, "het_p" = NA, "het_phi" = NA, "geno_p" = NA,
"geno_cramersV" = NA, "ks_p" = NA, "w1d" = NA, "ld_ks_p" = NA, "ld_w1d" = NA,
"gc_p" = NA, "gc_cohens" = NA)
#vary over all simulated pops
for(j in populations$pop){
#read real and sim pop
sim_geno <- read.csv(paste("../sim_output/",i,"/geno_encoding/geno_",j,".csv", sep = ""))
real_geno <- read.csv(paste("../data/NAM_genotype_data/geno_encoding/pop_",j,"_genos.csv", sep = ""))
sim_add <- read.csv(paste("../sim_output/",i,"/additive_encoding/add_",j,".csv", sep = ""))
real_add <- read.csv(paste("../data/NAM_genotype_data/additive_encoding/pop_",j,"_add.csv", sep = ""))
#constrain to same markers
sim_geno <- sim_geno[,genmap$Marker]
real_geno <- real_geno[,genmap$Marker]
sim_add <- sim_add[,genmap$Marker]
real_add <- real_add[,genmap$Marker]
##1. dist stats
#calculate # of het
sample <- sample(c(1:populations[populations$pop == j, "size"]), 20)
het_mat <- as.matrix(cbind(table(unlist(sim_add) == 0), table(unlist(real_add) == 0)))
#calc # of all genos
geno_names <- intersect(names(table(unlist(sim_geno))), names(table(unlist(real_geno))))
geno_mat <- as.matrix(cbind(table(unlist(sim_geno))[geno_names],
table(unlist(real_geno))[geno_names]))
#chisq.tests
het_p <- chisq.test(het_mat)$p.value
het_phi <- phi(het_mat)$phi_adjusted
geno_p <- chisq.test(geno_mat)$p.value
geno_cramersv <- cramers_v(geno_mat)$Cramers_v_adjusted
#ks test
ks_p <- ks.test(rowSums(sim_add), rowSums(real_add))$p.value
#wasserstein dist
w1d <- wasserstein1d(rowSums(sim_add), rowSums(real_add))
#gc content
haplo_mat_s <- cbind(apply(sim_geno,2,substr,1,1), apply(sim_geno,2,substr,2,2))
gc_vec_s <- apply(haplo_mat_s, 1, GC_cont)
haplo_mat_r <- cbind(apply(real_geno,2,substr,1,1), apply(real_geno,2,substr,2,2))
gc_vec_r <- apply(haplo_mat_r, 1, GC_cont)
gc_p <- t.test(gc_vec_s, gc_vec_r)$p.value
gc_cohens <- cohens_d(gc_vec_s, gc_vec_r)$Cohens_d
##2. popgen stats
sim_ld <- LD.decay(sim_add, ld_map)
sim_ld$all.LG <- sim_ld$all.LG[(sim_ld$all.LG$p < .001),]
sim_r2_D <- sim_ld$all.LG[c("r2", "d")]
real_ld <- LD.decay(real_add, ld_map)
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$p < .001),]
real_ld$all.LG <- real_ld$all.LG[(real_ld$all.LG$r2 < .99),]
real_r2_D <- real_ld$all.LG[c("r2", "d")]
#ks test + w1d on r2 measure
ld_ks_p <- ks.test(sim_r2_D$r2, real_r2_D$r2)$p.value
ld_w1d <- wasserstein1d(sim_r2_D$r2, real_r2_D$r2)
#adegenet does not like the original SNP names
#colnames(sim_add) <- c(1:974)
#genind <- df2genind(sim_add, sep = "")
#dist_sim <- as.numeric(dist.genpop(as.genpop(genind$tab), method = 4))
#colnames(real_add) <- c(1:974)
#genind <- df2genind(real_add, sep = "")
#dist_real <- as.numeric(dist.genpop(as.genpop(genind$tab), method = 4))
#
##rogers dist test
#rogers_p <- t.test(dist_sim, dist_real)$p.value
#rogers_cohen <- cohens_d(dist_sim, dist_real)$Cohens_d
#par(mfrow=c(1,2))
#boxplot(dist_sim, main = "Rogers distance of additive encoding simulated population", ylim=c(0.1,0.4))
#boxplot(dist_real, main = "Rogers distance of additive encoding real population", ylim=c(0.1,0.4))
#plot_ld_decay(real_r2_D, sim_r2_D, round(ld_ks_p,3), round(ld_w1d,2),
#              out_path = paste("../plots/popgen_plots/LD_decay/",i,"/ld_decay_",j,".png", sep = ""))
#format sumstats
p_vals <- c(het_p, geno_p, ks_p, ld_ks_p, gc_p)
p_vals <- ifelse(p_vals < 0.001, "<0.001", round(p_vals,3))
effects <- round(c(het_phi, geno_cramersv, w1d, ld_w1d, gc_cohens),2)
stats <- c(p_vals[1], effects[1], p_vals[2], effects[2], p_vals[3], effects[3], p_vals[4], effects[4],
p_vals[5], effects[5])
sum_stats[sum_stats$population == j, c("het_p", "het_phi", "geno_p", "geno_cramersV", "ks_p", "w1d",
"ld_ks_p", "ld_w1d", "gc_p", "gc_cohens")] <- stats
}
print("finished")
write.csv(sum_stats, paste("../stats/sum_stats_",i,".csv", sep = ""), row.names = FALSE)
sum_stats
transport()
?transport
?wasserstein1d
transport(c(1,2,3),c(1,2,3), method = "gaussian")
w1d
min(rowSums(sim_add), rowSums(real_add))
min(sum(rowSums(sim_add)), sum(rowSums(real_add)))
w1d/-51973
runif(500,0,2)
low <- runif(500,0,2)
high <- runif(500, 5, 10)
high <- runif(500, 5, 7)
high
min(sum(low), sum(high))
wasserstein1d(low, high)
high <- runif(500, 10, 12)
min(sum(low), sum(high))
wasserstein1d(low, high)
install.packages("philentropy")
library(philentropy)
P <- 1:10/sum(1:10)
Q <- 20:29/sum(20:29)
x <- rbind(P,Q)
JSD(x)
P
Q
P <- 1:10/sum(1:10)
Q <- 10:19/sum(20:29)
x <- rbind(P,Q)
JSD(x)
P <- 1:10/sum(1:10)
Q <- 10:19/sum(10:19)
x <- rbind(P,Q)
JSD(x)
P <- 1:10/sum(1:10)
Q <- 3:13/sum(3:13)
x <- rbind(P,Q)
JSD(x)
P
q
Q
x
JSD(rbind(rowSums(sim_add),rowSums(real_add)))
sum(1:10)
JSD(rbind(rowSums(sim_add),rowSums(real_add)), est.prob = TRUE)
JSD(rbind(rowSums(sim_add),rowSums(real_add)), est.prob = "empirical")
rbind(rowSums(sim_add),rowSums(real_add))
sum_stats
sum(real_r2_D)
sum(real_r2_D$r2)
sum(rowSums(sim_add))
mean(real_r2_D$r2)
mean(rowSums(sim_add))
sum_stats
sum_results
length(real_r2_D$r2)
length(sim_r2_D$r2)
cohens_d(rowSums(sim_add), rowSums(real_add))
cohens_d(sim_r2_D$r2, real_r2_D$r2)
wasserstein1d(gc_vec_s, gc_vec_r)
